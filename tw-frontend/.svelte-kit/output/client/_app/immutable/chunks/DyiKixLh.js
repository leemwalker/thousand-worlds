import{w as u}from"./B0GIxsE8.js";class s extends Error{constructor(r,a,t){super(r),this.userFriendly=a,this.originalError=t,this.name="AuthError"}}const o={INVALID_CREDENTIALS:{title:"Login Failed",message:"Incorrect email or password. Please try again."},NETWORK_ERROR:{title:"Connection Problem",message:"Unable to reach the server. Please check your internet connection and try again."},SERVER_ERROR:{title:"Server Error",message:"The server is experiencing issues. Please try again in a few moments."},EMAIL_EXISTS:{title:"Account Already Exists",message:"An account with this email already exists."},WEAK_PASSWORD:{title:"Weak Password",message:"Password must be at least 8 characters."},INVALID_EMAIL:{title:"Invalid Email",message:"Please enter a valid email address."},TIMEOUT:{title:"Request Timeout",message:"The request took too long. Please try again."}},n="/api";class g{async fetchWithErrorHandling(r,a){var t;try{const e=await fetch(r,{...a,credentials:"include",headers:{"Content-Type":"application/json",...a==null?void 0:a.headers}});if(!e.ok){let c;try{c=await e.json()}catch{throw new s("Server error",o.SERVER_ERROR)}if(e.status===401)throw new s("Invalid credentials",o.INVALID_CREDENTIALS);if(e.status===409)throw new s("Conflict",o.EMAIL_EXISTS);if(e.status>=500)throw new s("Server error",o.SERVER_ERROR);const l=((t=c.error)==null?void 0:t.message)||c.error||"Request failed";throw new s(typeof l=="string"?l:"Request failed",{title:"Request Failed",message:typeof l=="string"?l:"An unexpected error occurred."})}return e.status===204?null:e.json()}catch(e){throw e instanceof s?e:new s("Network error",o.NETWORK_ERROR,e)}}async register(r,a,t){return this.fetchWithErrorHandling(`${n}/auth/register`,{method:"POST",body:JSON.stringify({email:r,username:a,password:t})})}async login(r,a){return this.fetchWithErrorHandling(`${n}/auth/login`,{method:"POST",body:JSON.stringify({email:r,password:a})})}async getMe(){return this.fetchWithErrorHandling(`${n}/auth/me`)}logout(){this.fetchWithErrorHandling(`${n}/auth/logout`,{method:"POST"}).catch(r=>console.error("Logout error:",r))}async getCharacters(){return this.fetchWithErrorHandling(`${n}/game/characters`)}async createCharacter(r){return this.fetchWithErrorHandling(`${n}/game/characters`,{method:"POST",body:JSON.stringify(r)})}async getSkills(r){var a;try{return await this.fetchWithErrorHandling(`${n}/game/skills?character_id=${r}`)}catch(t){throw t instanceof s&&((a=t.originalError)==null?void 0:a.status)===404&&console.warn("Skills endpoint not found, returning empty skills"),t}}}const R=new g;function d(){const{subscribe:i,set:r,update:a}=u({data:null,lastUpdate:0});return{subscribe:i,setMapData:t=>{a(e=>({...e,data:t,lastUpdate:Date.now()}))},clear:()=>r({data:null,lastUpdate:0})}}const f=d(),h={user:null,currentCharacter:null,messages:[],inventory:[],stats:{hp:100,max_hp:100,stamina:100,max_stamina:100,mana:100,max_mana:100,level:1,xp:0},nearbyEntities:[],isLoading:!1,error:null};function m(){const{subscribe:i,update:r,set:a}=u(h);return{subscribe:i,setUser:t=>r(e=>({...e,user:t})),clearUser:()=>r(t=>({...t,user:null,currentCharacter:null})),setCharacter:t=>r(e=>({...e,currentCharacter:t})),addMessage:t=>r(e=>({...e,messages:[...e.messages,t].slice(-100)})),setInventory:t=>r(e=>({...e,inventory:t})),updateStats:t=>r(e=>({...e,stats:{...e.stats,...t}})),setLoading:t=>r(e=>({...e,isLoading:t})),setError:t=>r(e=>({...e,error:t})),reset:()=>a(h)}}const y=m();export{y as a,R as g,f as m};
